"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  EXTERNAL_URL_RE: () => EXTERNAL_URL_RE,
  RssPlugin: () => RssPlugin,
  clearMatterContent: () => clearMatterContent,
  formatDate: () => formatDate,
  genFeed: () => genFeed,
  getDefaultTitle: () => getDefaultTitle,
  getFileBirthTime: () => getFileBirthTime,
  getTextSummary: () => getTextSummary,
  isWindows: () => isWindows,
  joinPath: () => joinPath,
  normalizePath: () => normalizePath,
  slash: () => slash,
  withBase: () => withBase
});
module.exports = __toCommonJS(src_exports);

// src/node.ts
var import_node_fs = __toESM(require("fs"));
var import_node_path2 = __toESM(require("path"));
var import_node_process = __toESM(require("process"));
var import_fast_glob = __toESM(require("fast-glob"));
var import_gray_matter = __toESM(require("gray-matter"));
var import_feed = require("feed");

// src/utils/index.ts
var import_node_os = __toESM(require("os"));
var import_node_path = __toESM(require("path"));
var import_node_child_process = require("child_process");
function formatDate(d, fmt = "yyyy-MM-dd hh:mm:ss") {
  if (!(d instanceof Date)) {
    d = new Date(d);
  }
  const o = {
    "M+": d.getMonth() + 1,
    // 月份
    "d+": d.getDate(),
    // 日
    "h+": d.getHours(),
    // 小时
    "m+": d.getMinutes(),
    // 分
    "s+": d.getSeconds(),
    // 秒
    "q+": Math.floor((d.getMonth() + 3) / 3),
    // 季度
    "S": d.getMilliseconds()
    // 毫秒
  };
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(
      RegExp.$1,
      `${d.getFullYear()}`.substr(4 - RegExp.$1.length)
    );
  }
  for (const k in o) {
    if (new RegExp(`(${k})`).test(fmt))
      fmt = fmt.replace(
        RegExp.$1,
        RegExp.$1.length === 1 ? o[k] : `00${o[k]}`.substr(`${o[k]}`.length)
      );
  }
  return fmt;
}
var windowsSlashRE = /\\/g;
var isWindows = import_node_os.default.platform() === "win32";
function slash(p) {
  return p.replace(windowsSlashRE, "/");
}
function normalizePath(id) {
  return import_node_path.default.posix.normalize(isWindows ? slash(id) : id);
}
function getDefaultTitle(content) {
  var _a, _b;
  const title = ((_b = (_a = clearMatterContent(content).split("\n")) == null ? void 0 : _a.find((str) => {
    return str.startsWith("# ");
  })) == null ? void 0 : _b.slice(2).replace(/[\s]/g, "")) || "";
  return title;
}
function clearMatterContent(content) {
  let first___;
  let second___;
  const lines = content.split("\n").reduce((pre, line) => {
    if (!line.trim() && pre.length === 0) {
      return pre;
    }
    if (line.trim() === "---") {
      if (first___ === void 0) {
        first___ = pre.length;
      } else if (second___ === void 0) {
        second___ = pre.length;
      }
    }
    pre.push(line);
    return pre;
  }, []);
  return lines.slice(second___ || 0).join("\n");
}
function getFileBirthTime(url) {
  var _a;
  let date = /* @__PURE__ */ new Date();
  try {
    const infoStr = (_a = (0, import_node_child_process.spawnSync)("git", ["log", "-1", '--pretty="%ci"', url]).stdout) == null ? void 0 : _a.toString().replace(/["']/g, "").trim();
    if (infoStr) {
      date = new Date(infoStr);
    }
  } catch (error) {
    return formatDate(date);
  }
  return formatDate(date);
}
function getTextSummary(text, count = 100) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  return (_k = (_j = (_i = (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a = clearMatterContent(text).match(/^# ([\s\S]+)/m)) == null ? void 0 : _a[1]) == null ? void 0 : _b.replace(/#/g, "")) == null ? void 0 : _c.replace(/!\[.*?\]\(.*?\)/g, "")) == null ? void 0 : _d.replace(/\[(.*?)\]\(.*?\)/g, "$1")) == null ? void 0 : _e.replace(/\*\*(.*?)\*\*/g, "$1")) == null ? void 0 : _f.split("\n")) == null ? void 0 : _g.filter((v) => !!v)) == null ? void 0 : _h.slice(1)) == null ? void 0 : _i.join("\n")) == null ? void 0 : _j.replace(/>(.*)/, "")) == null ? void 0 : _k.slice(0, count);
}
var EXTERNAL_URL_RE = /^[a-z]+:/i;
function joinPath(base, path3) {
  return `${base}${path3}`.replace(/\/+/g, "/");
}
function withBase(base, path3) {
  return EXTERNAL_URL_RE.test(path3) || path3.startsWith(".") ? path3 : joinPath(base, path3);
}

// src/node.ts
var imageRegex = /!\[.*?\]\((.*?)\s*(".*?")?\)/;
function getPostsData(srcDir, config, ops) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d;
    const files = import_fast_glob.default.sync(`${srcDir}/**/*.md`, { ignore: ["node_modules"] });
    const { createMarkdownRenderer } = yield import("vitepress");
    const mdRender = yield createMarkdownRenderer(
      config.srcDir,
      config.markdown,
      config.site.base,
      config.logger
    );
    const posts = [];
    for (const file of files) {
      const fileContent = import_node_fs.default.readFileSync(file, "utf-8");
      const { data: frontmatter, excerpt } = (0, import_gray_matter.default)(fileContent, {
        excerpt: true
      });
      if (!frontmatter.title) {
        frontmatter.title = getDefaultTitle(fileContent);
      }
      if (!frontmatter.date) {
        frontmatter.date = getFileBirthTime(file);
      } else {
        frontmatter.date = formatDate(new Date(frontmatter.date));
      }
      frontmatter.description = (_b = yield (_a = ops == null ? void 0 : ops.renderExpect) == null ? void 0 : _a.call(ops, fileContent, __spreadValues({}, frontmatter))) != null ? _b : frontmatter.description || excerpt;
      frontmatter.cover = ((_d = frontmatter.cover) != null ? _d : (_c = fileContent.match(imageRegex)) == null ? void 0 : _c[1]) || "";
      const html = mdRender.render(fileContent);
      const url = config.site.base + normalizePath(import_node_path2.default.relative(config.srcDir, file)).replace(/(^|\/)index\.md$/, "$1").replace(/\.md$/, config.cleanUrls ? "" : ".html");
      posts.push({
        filepath: file,
        fileContent,
        html,
        description: frontmatter.description,
        date: frontmatter.date,
        title: frontmatter.title,
        url,
        frontmatter
      });
    }
    return posts;
  });
}
function genFeed(config, rssOptions) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d;
    if (!rssOptions)
      return;
    const srcDir = config.srcDir.replace(config.root, "").replace(/^\//, "") || ((_a = import_node_process.default.argv.slice(2)) == null ? void 0 : _a[1]) || ".";
    const { baseUrl, filename, ignoreHome = true, filter: filterPost = () => true } = rssOptions;
    const feed = new import_feed.Feed(__spreadValues({
      id: rssOptions.baseUrl,
      link: rssOptions.baseUrl
    }, rssOptions));
    const posts = (yield getPostsData(srcDir, config, {
      renderExpect: rssOptions.renderExpect
    })).filter((p) => {
      if (p.frontmatter.layout === "home" && ignoreHome) {
        return false;
      }
      if (p.frontmatter.publish === false)
        return false;
      return true;
    }).filter(filterPost);
    posts.sort(
      (a, b) => +new Date(b.date) - +new Date(a.date)
    );
    if (void 0 !== (rssOptions == null ? void 0 : rssOptions.limit) && (rssOptions == null ? void 0 : rssOptions.limit) > 0) {
      posts.splice(rssOptions.limit);
    }
    for (const post of posts) {
      const { title, description, date, frontmatter, url, html } = post;
      const author = frontmatter.author || ((_b = rssOptions.author) == null ? void 0 : _b.name);
      const authorInfo = (_c = rssOptions.authors) == null ? void 0 : _c.find((v) => v.name === author);
      const link = `${baseUrl}${url}`;
      feed.addItem({
        title,
        id: link,
        link,
        description,
        content: html,
        author: [
          __spreadValues({
            name: author
          }, authorInfo)
        ],
        image: (frontmatter == null ? void 0 : frontmatter.cover) ? new URL(frontmatter == null ? void 0 : frontmatter.cover, baseUrl).href : "",
        date: new Date(date)
      });
    }
    const RSSFilename = filename || "feed.rss";
    const RSSFilepath = import_node_path2.default.join(config.outDir, RSSFilename);
    (0, import_node_fs.writeFileSync)(RSSFilepath, feed.rss2());
    if ((_d = rssOptions.log) != null ? _d : true) {
      console.log("\u{1F389} RSS generated", RSSFilename);
      console.log("rss filepath:", RSSFilepath);
      console.log("rss url:", `${baseUrl}${config.site.base + RSSFilename}`);
      console.log("include", posts.length, "posts");
      console.log();
    }
  });
}

// src/index.ts
var svgIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 448 512"><title>RSS</title><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48s48 21.49 48 48s-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634c-5.214-80.05-69.243-143.92-149.123-149.123c-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425c110.546 5.974 198.997 94.536 204.964 204.964c.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038c-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432c167.83 6.025 302.21 141.191 308.205 308.205c.232 6.449-4.978 11.787-11.432 11.787z" fill="currentColor"></path></svg>';
function RssPlugin(rssOptions) {
  let resolveConfig;
  const pluginOps = {
    name: "vitepress-plugin-rss",
    enforce: "pre",
    configResolved(config) {
      var _a;
      if (resolveConfig) {
        return;
      }
      resolveConfig = config;
      const VPConfig = config.vitepress;
      if (!VPConfig) {
        return;
      }
      if ((_a = rssOptions.icon) != null ? _a : true) {
        const icon = typeof rssOptions.icon === "string" ? rssOptions.icon : svgIcon;
        VPConfig.site.themeConfig.socialLinks = [
          {
            icon: {
              svg: icon
            },
            link: rssOptions.url || `${rssOptions.baseUrl}${VPConfig.site.base + (rssOptions.filename || "feed.rss")}`,
            ariaLabel: (rssOptions == null ? void 0 : rssOptions.ariaLabel) || "RSS"
          },
          ...VPConfig.site.themeConfig.socialLinks
        ];
      }
      const selfBuildEnd = VPConfig.buildEnd;
      VPConfig.buildEnd = (siteConfig) => __async(this, null, function* () {
        yield selfBuildEnd == null ? void 0 : selfBuildEnd(siteConfig);
        yield genFeed(siteConfig, rssOptions);
      });
    }
  };
  return pluginOps;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EXTERNAL_URL_RE,
  RssPlugin,
  clearMatterContent,
  formatDate,
  genFeed,
  getDefaultTitle,
  getFileBirthTime,
  getTextSummary,
  isWindows,
  joinPath,
  normalizePath,
  slash,
  withBase
});
